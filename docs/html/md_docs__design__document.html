<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Micro++: Design Document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Micro++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design Document </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Our Project</h2>
<p>Micro++ is a lightweight web-framework that allows for rapid production of web-applications written in C++. The web-framework wraps a multithreaded HTTP server which is built using the asynchronous C++ networking library, ASIO. Micro++ provides a user friendly interface that allows web developers to register callback functions with associated url routes. These callbacks provide a user-friendly API to handle HTTP requests and send back HTTP responses.</p>
<h2>What is a Web Framework</h2>
<p>At its core, a web-framework provides an interface to build web based applications. The interface provides application developers a clean and easy way to handle requests and send responses without dealing with the complexities of the strict HTTP protocol.</p>
<p>Web-Frameworks today work off the Model-View-Controller paradigm which modularizes code into three distinct sections. The Model represents the fundamental data structures that are persisted in a database. These objects are often modeled to be stored in SQL databases like MySQL or document databases like MongoDB. A View is a html page or template that gets rendered to the user. These are the web pages that a user of the web application will see in his or her browser. The controller is where the logic of the web application resides. The controller maps callback functions to URL routes which allow application developers to handle the request sent to the designated route and serve a custom response to the user who accessed the web application. Within the controller a developer typically performs CRUD (Create, Read, Update, and Delete) operations on objects defined by the model.</p>
<p>Some of the most popular services for web application frameworks include Django and Flask for Python, Rails for Ruby, and Express for NodeJs. Django and Rails are more complicated choices with more features while Flask and Express are more lightweight. Currently, the most popular web-framework for C++ is WT, which has a complicated "widget-centric" design unlike any popular framework on the market. Therefore, we decided to build our own micro framework in C++, using Flask and Express as inspiration given their lightweight yet robust design.</p>
<h2>Web-Framework vs Web Server</h2>
<p>A HTTP web server is a software program which stores, processes, and serves web pages to clients using the HTTP protocol. Although this sounds very similar to a web-framework, the key difference is that the framework sits on top of a web server providing a much more user friendly API for handling HTTP requests and serving HTTP responses.</p>
<p>Web-frameworks like Flask provide simple built in web-servers for development purposes. This server, however, is not intended for production use. The documentation reads:</p>
<blockquote class="doxtable">
<p>â€œYou can use the builtin server during development, but you should use a full deployment option for production applications. (Do not use the builtin development server in production.)"" </p>
</blockquote>
<p>In order to scale, web-frameworks like Flask interface with production servers by implementing CGI (Common Gateway Interface) protocols. Python uses a slightly different protocol for python called WSGI (Web Server Gateway Interface). With WSGI, Flask applications can be run on robust, production ready servers like Apache or Nginx.</p>
<h2>Building a Web-App</h2>
<h3>Basic Structure</h3>
<p>The foundation of building a web-application begins with constructing an <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> object, setting the route of a static file directory, and running the application. Underneath the hood, <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> initiates an underlying web-server which can be interfaced through the <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code>. The default <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> constructor sets the port to <code>8080</code> and address <code>0.0.0.0</code>. The constructor allows you to set the port and address to custom values. The <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> has other customizable features documented in the API such as setting the thread count for the server, turning on debug mode, and setting the route for your static file directory. Below, we give an example of a simple web application which serves static files contained within the directory <code>./static</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <a class="code" href="classmicro_1_1app.html">micro::app</a> application;</div>
<div class="line">    application.<a class="code" href="classmicro_1_1app.html#add07670b87b2dc2c7758aabdb365a2a8">set_static_root</a>(<span class="stringliteral">&quot;./static&quot;</span>);</div>
<div class="line">    application.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Given that a file exists in the directory <code>./static</code> such as example_image.jpg, you can access this image through the browser at <code>localhost:8080/example_image.jpg</code>.</p>
<h2>Routing</h2>
<p>The advantage of using a web-framework is that it provides an easy and clean method to attach callback function to URL endpoints. To make URL routing as user-friendly as possible, we require a two-step process:</p>
<ol type="1">
<li>Defining a callback function.</li>
<li>Register a route with the callback function.</li>
</ol>
<h3>Step 1: The Callback Function</h3>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> callback(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle request and response here</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Every route has an associated callback function which passes a<code><a class="el" href="classmicro_1_1request.html" title="The request object provides an API that allows developers access to data from a HTTP request...">micro::request</a></code> and returns a <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code>. <code><a class="el" href="classmicro_1_1request.html" title="The request object provides an API that allows developers access to data from a HTTP request...">micro::request</a></code> is passed in by const reference given that a user does not modify a request. The application developer only extracts data stored in the request object, using this information to provide an appropriate <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code>. The <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> object is modifiable and has an API providing customization for the <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code>.</p>
<p>A response object must always be constructed and returned in the callback. We made this design choice because the HTTP protocol require web servers to always respond to a HTTP request. The design of the callback is largely borrowed from the design of the Javascript Express web framework as illustrated here:</p>
<h3>Express Callback Example</h3>
<div class="fragment"><div class="line">app.get(<span class="charliteral">&#39;/&#39;</span>, <span class="keyword">function</span>(req, res){</div>
<div class="line">    res.send(<span class="stringliteral">&#39;hello world&#39;</span>);</div>
<div class="line">});</div>
</div><!-- fragment --><p>Like Express, we originally passed the request and response as parameters into the callback. Although this may reduce two two lines of code, we thought that that returning a <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> led to clearer programming style.</p>
<h3>Anonymous Callbacks</h3>
<p>Like Express, users can provide an anonymous callback using a lambda expression, but we recommend users to define their callback functions for clearer coding style. In the example below, accessing the route <code>/lambda</code> returns the message "hello lambda."</p>
<div class="fragment"><div class="line">application.add_route(<span class="stringliteral">&quot;/lambda&quot;</span>, [](<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req) {</div>
<div class="line">      <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">      res.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(<span class="stringliteral">&quot;hello lambda&quot;</span>);</div>
<div class="line">      <span class="keywordflow">return</span> res;</div>
<div class="line">  });</div>
</div><!-- fragment --><h3>The Request Object</h3>
<p>The request object is populated with data parsed from the HTTP request and transformed into a more user friendly C++ object.</p>
<h4>Example: Getting data From the Request Object</h4>
<div class="fragment"><div class="line"><span class="comment">// Define callback</span></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> api_callback(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">    std::string user = req.get_url_param(<span class="stringliteral">&quot;username&quot;</span>); </div>
<div class="line"></div>
<div class="line">    <span class="comment">// Logic on for handling the user</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// In the main method, set the callback function to dynamic route</span></div>
<div class="line">application.add_route(<span class="stringliteral">&quot;/api/user/&lt;username&gt;&quot;</span>, api_callback);</div>
</div><!-- fragment --><p>In the example above, if a user accesses the URL <code>www.example.com/api/bjarne</code>, access to the username "bjarne" is available through the <code>micro::request::get_url_param</code> method.</p>
<p>Other methods available for <code><a class="el" href="classmicro_1_1request.html" title="The request object provides an API that allows developers access to data from a HTTP request...">micro::request</a></code> can be viewed in the API.</p>
<h3>The Response Object</h3>
<p>The response object is modified within the callback and will be sent as an appropriately formatted HTTP response after the callback function has been executed.</p>
<h4>Example: Setting Data in the Response Object</h4>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> api_callback(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">    std::string user = req.get_url_param(<span class="stringliteral">&quot;username&quot;</span>);</div>
<div class="line">    std::string message = <span class="stringliteral">&quot;Hello &quot;</span> + user;</div>
<div class="line">    res.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(message)</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example above, if a client accesses the URL <code>www.example.com/api/bjarne</code>, the client would receive a message "hello bjarne".</p>
<p>Other methods available for <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> can be viewed in the API.</p>
<h3>Step 2: Registering a Route</h3>
<p>After defining a callback function, the callback can be registered for a particular route. In order to register a route, you must call <code>micro::app::add_route</code> on the <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> instance. Here are examples of various valid routes that can be registered to different callback functions:</p>
<div class="fragment"><div class="line">application.add_route(<span class="stringliteral">&quot;/api&quot;</span>, api_callback);</div>
<div class="line">application.add_route(<span class="stringliteral">&quot;/api/users&quot;</span>, users_callback);</div>
<div class="line">application.add_route(<span class="stringliteral">&quot;/api/groups&quot;</span>, groups_callback);</div>
</div><!-- fragment --><h3>Dynamic Routes</h3>
<p>In order to add convenience to users we provide a system for generating dynamic routes. It would be absurd to define a route for each user. Instead, you define a dynamic route like so:</p>
<div class="fragment"><div class="line">application.add_route(<span class="stringliteral">&quot;/api/user/&lt;username&gt;&quot;</span>, callback);</div>
</div><!-- fragment --><p>OR</p>
<div class="fragment"><div class="line">application.add_route(<span class="stringliteral">&quot;/api/user/&lt;int:id&gt;&quot;</span>, callback);</div>
</div><!-- fragment --><p>A user can define a route with an string or integer which is possible through complex regex parsing on the URL.</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;^(/((&lt;[A-Za-z0-9_\\-]+&gt;)|(&lt;int:[A-Za-z0-9_\\-]+&gt;)|([A-Za-z0-9_\\-\\.]+)))*/?$&quot;</span></div>
</div><!-- fragment --><p>With dynamic routes, the application developer can define a route and extract the variable parameters from <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> in the callback. Routes such as <code>www.example.com/api/user/1</code> and <code>www.example.com/api/user/2</code> can be processed differently within the same callback. This allows for more concise and modular code.</p>
<h3>Defining the HTTP Method</h3>
<p>Within the callback, users can check the HTTP method and respond to different methods using <code>if</code> statements.</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> test_methods(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">    <span class="keywordflow">if</span> (req.<a class="code" href="classmicro_1_1request.html#a8f6a224448ab51600cdf692ebc5d8b84">get_method</a>() == <span class="stringliteral">&quot;GET&quot;</span>) {</div>
<div class="line">        <span class="comment">// Respond to GET request</span></div>
<div class="line">        <span class="keywordflow">return</span> res;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (req.<a class="code" href="classmicro_1_1request.html#a8f6a224448ab51600cdf692ebc5d8b84">get_method</a>() == <span class="stringliteral">&quot;POST&quot;</span>) {</div>
<div class="line">        <span class="comment">// Respond toe POST request</span></div>
<div class="line">        <span class="keywordflow">return</span> res;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We found that this leads to messy and unnecessarily long callback functions. To encourage better code design, we give users the ability to define the HTTP method when registering the route so that multiple callbacks can be pointed at the same URL.</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> post(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">    res.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(<span class="stringliteral">&quot;POST&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> <span class="keyword">get</span>(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> res;</div>
<div class="line">    res.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(<span class="stringliteral">&quot;GET&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv){</div>
<div class="line">    <a class="code" href="classmicro_1_1app.html">micro::app</a> application;</div>
<div class="line">    application.add_route(<span class="stringliteral">&quot;/get_or_post&quot;</span>, <span class="keyword">get</span>, {<span class="stringliteral">&quot;GET&quot;</span>});</div>
<div class="line">    application.add_route(<span class="stringliteral">&quot;/get_or_post&quot;</span>, post, {<span class="stringliteral">&quot;POST&quot;</span>});</div>
<div class="line">    application.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example shows the encouraged usage of multiple callbacks for the same URL. Such practices lead more compact and cleaner callbacks. This design was borrowed from Flask, which also allows you to define the method for the route.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;@app.route(<span class="stringliteral">&#39;/login&#39;</span>, methods=[<span class="stringliteral">&#39;POST&#39;</span>])</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">def </span>login():</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    <span class="keywordflow">if</span> request.method == <span class="stringliteral">&#39;POST&#39;</span>:</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        do_the_login()</div>
</div><!-- fragment --><h3>Route Modules</h3>
<p>For user convenience we added the ability to build route modules so that application developers can create more modular code with associated routes in separate files. The <code>micro::module</code> allows programmers to register routes to callbacks, but bind them to the application at a later time. For instance, suppose you want to include admin functionality in your blog. Admins should have access to a login, dashboard, and edit_user page. All of these things can be logically grouped together in an "admin" module. Suppose you already have callback functions for these three pages. Then, you can do:</p>
<div class="fragment"><div class="line">micro::module mod = { {<span class="stringliteral">&quot;/login&quot;</span>, admin_login},</div>
<div class="line">                      {<span class="stringliteral">&quot;/dashboard&quot;</span>, admin_dashboard},</div>
<div class="line">                      {<span class="stringliteral">&quot;/edit_user&quot;</span>, admin_edit_user} </div>
<div class="line">                    };</div>
</div><!-- fragment --><p>Later, we can register this module with the application, under the prefix "/admin/", as follows:</p>
<div class="fragment"><div class="line">app.add_module(mod, <span class="stringliteral">&quot;/admin&quot;</span>);</div>
</div><!-- fragment --><p>Now, all of the urls in the module will be accessible from the "admin" entry point. For instance, we can access <code><a href="http://www.example.com/admin/login">http://www.example.com/admin/login</a></code>. Suppose that from the login page, you want to redirect to the dashboard. This is a redirect within the module, so doing the following will not work:</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> admin_login(<a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req){</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp; </div>
<div class="line">    <span class="comment">//Do login stuff.. </span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(authorized) resp.<a class="code" href="classmicro_1_1response.html#ad33c5cf35cef13c19b15edbb70c1f0d8">redirect</a>(/dashboard); </div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The example above will not work because it redirects to <code>/dashboard</code> instead of <code>/admin/dashboard</code>. Instead, the code must be modified as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> admin_login(<a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req){</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp; </div>
<div class="line">    <span class="comment">//Do login stuff.. </span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(authorized) resp.<a class="code" href="classmicro_1_1response.html#ad33c5cf35cef13c19b15edbb70c1f0d8">redirect</a>(/dashboard, <span class="keyword">true</span>); </div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>true</code> flag added to the redirect function indicates that we intend to redirect within the module. Now, the function will redirect to <code>/admin/dashboard</code>.</p>
<p>The entire module can be constructed in a separate header file, which can be imported by the programmer. Thus, the intricacies of the module functionality are abstracted away. All that the end user of a module needs to do is to bind that module to the application!</p>
<h2>The Server</h2>
<p>We based our server on the Boost.Asio example server, built by Chris Kohloff. The original server is located <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/boost_asio/examples.html#boost_asio.examples.http_server_4">here</a>. We built on top of this server and molded it to comply with our web framework.</p>
<p>In our final product, the server is built on a hybrid between an asynchronous and multi-threaded model. All client-server communication is done asynchronously. That is, new sockets are accepted asynchronously, data is read from these sockets asynchronously, and the response is sent back asynchronously. After a request is received in full, it is added to a thread safe work queue. Threads from a pool process each request, determine which callback to use, and then invoke that callback on the request. When the callback completes, the thread schedules the response for asynchronous write-back to the client. An ancillary thread periodically tracks the progress of the thread pool, canceling any threads that have run longer than allowed by the user-specified (or else, default) timeout.</p>
<h3>Boost.Asio Library</h3>
<p>The asynchronous portion of micro++ is built upon the Asio io_service. The io_service forms an asynchronous queue, constantly accepting new sockets, reading from open sockets, and sending responses back to clients. The asynchronous loop only rests when there is no work to be done.</p>
<h3>Optimizations</h3>
<p>Asynchronous client-server communication ensures that our server never blocks when receiving and responding to requests. Furthermore, we made the design decision to execute callbacks on separate threads. This allows us to monitor the execution time of threads (so that they do not exceed the timeout). Furthermore, threads that issue file IO requests can sleep and immediately hand off control to other threads, so that file IO never blocks.</p>
<p>To make micro++ fast, we paid particular attention to url resolution. That is, when our framework receives a request, we attempt to match it with a callback function as quickly as possible. At first, we maintained an unordered map, which mapped url strings to callback functions. We had a separate function that would test incoming requests and attempt to match them to the appropriate callback. Due to the indirection associated with unordered map lookups, we believe that this approach slowed micro++ down.</p>
<p>Later, we implemented the <code>url_route</code> object, which stores the a regex and associated callback function. <code>url_route</code>s are stored in a vector, so iterating over them and finding a match is likely done in cache. While we do not yet have exact measurements, we believe that this approach made micro++ faster. See the accompanying document titled "Benchmarks: Speed Tests, Clarity, and Ease of Use" for more discussion.</p>
<h3>Blocking Callback Functions: A Potential Speed Drawback</h3>
<p>It must be noted that micro++ knows nothing about the implementation of callbacks, so it is up to the user to make sure that callback functions do not block. For network communications that may block - like querying a third-party API - users are encouraged to maintain a separate asynchronous io thread, perhaps using boost::asio::io_service.</p>
<h3>Error Handling</h3>
<p>We take care to make sure that exceptions within callback functions do not bring down the whole server. To achieve this, all callbacks are invoked in try-catch blocks. When debug mode is on, any exception that results from hitting a specific url endpoint is displayed in the browser. When debug mode is off, all exceptions result in the server returning a "500: internal server error" status. In either case, the exception is logged to the console. We hope to make error handling and debug mode more robust in the future.</p>
<h2>Installation</h2>
<p>To make it easy to build, install, and use this library on virtually any Unix-like system, we used GNU autotools to manage our build chain. The Makefile.am file in the src/ directory defines all of the source files that are needed to build micro++, as well as all of the header files that need to be included on a user's system. With this file, and the boilerplate configure.ac file, a user simply needs to generate a configure script (along with other associated files) using <code>autoreconf -i</code>, and after running that configure script, they will have Makefiles that are generated correctly for their system.</p>
<p>These Makefiles let a user build the library with a simple <code>make</code> command, as well as conveniently install it and its headers in the /usr/local/ directory without any further configuration.</p>
<p>Using autotools makes it easy for a user to port the micro++ library to any Unix-like architecture that is capable of running boost. This means micro++ can run on anything from a Raspberry Pi to a supercomputer.</p>
<h2>Additions for 1.2</h2>
<h3>JSON handling</h3>
<p>One of the main advantages of writing a web-application in python or javascript is the easy conversion of objects into JSON. JSON has become the most popular convention for buiding public APIs. For python, different data types including strings, numbers, and arrays can all be stored in the same dictionary and easily converted into a JSON object. For javascript, any javascript object can be converted into JSON. Although custom methods could be created to parse C++ objects to JSON, this requires a lot of extra work compared to python and javascript. In version 1.2 we would like to build an interface that can assist with JSON serialization.</p>
<h3>Templating</h3>
<p>One missing feature from our framework is the ability to easily template HTML. Other languages have robust templating engines (such as Jinja for Python). However, we have not found a templating engine for C++ that is both well-maintained and simple. Since templating engines are of utmost importance to web development, we hope to address this issue in the future. One option is to write our own templating engine. Another option is to use an already existing - and perhaps orphaned - open-source templating engine, and incorporate it into our library with a simplified wrapper.</p>
<h3>Interface with industry server like Nginx or Apache</h3>
<p>As discussed above, most web-frameworks have interfaces to connect to production strength servers. In the future we would like to provide users with the abiliy to interface with a CGI protocol so that application developers can connect the web framework to servers like Apache or Nginx</p>
<h3>Allow interface for middleware</h3>
<p>Add an interface to connect middleware so that other developers can build libraries that work with micro++. Express has an extensive collection of middleware libraries that provide useful functionality such as cookie signing and encryption and more robust multi-part HTTP content body parsers. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 30 2015 22:30:20 for Micro++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
