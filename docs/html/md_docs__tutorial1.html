<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Micro++: Tutorial: Building the basic bjarneblog</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Micro++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial: Building the basic bjarneblog </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, we will teach you how to build a basic blogging application, step-by-step, using micro++. This tutorial will assume that you have installed micro++. If you haven't already, follow the installation instructions in README.md or on the homepage of the Doxygen output.</p>
<h2>Getting Started</h2>
<p>A web-application is actually very simple and micro++ will help you get your application running very quickly. At its core a web-framework provides developers with an easy way to handle requests from users and send responses to these users. The micro++ framework defines a clean interface where you register a callback function to a specified route. Within a callback, the developer can easily access the contents of the request through the <code><a class="el" href="classmicro_1_1request.html" title="The request object provides an API that allows developers access to data from a HTTP request...">micro::request</a></code> API and construct a <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> that will be sent back to the client. This idea, though simple, lets you build incredibly flexible and even complex web applications that will run blazingly fast.</p>
<p>To get started, create a new directory where you will build the app, open up a new file named <code>blog_app.cpp</code>, and write the following code:</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;micro/app.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;micro/response.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;micro/request.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> hello(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(<span class="stringliteral">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <a class="code" href="classmicro_1_1app.html">micro::app</a> app;</div>
<div class="line">    app.add_route(<span class="stringliteral">&quot;/&quot;</span>, hello);</div>
<div class="line">    app.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>And create the following Makefile:</p>
<p><b>Makefile</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;CXXFLAGS = -std=c++11</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;LDLIBS = -lmicro -lboost_system -lboost_log-mt -lpthread</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;blog_app: </div>
</div><!-- fragment --><p>If you are on Linux, replace <code>lboost_log-mt</code> with <code>lboost_log</code>.</p>
<p>Now, when you run the compiled <code>blog_app</code> with <code>./blog_app</code>, opening up the URL localhost:8080/ in your browser will display “Hello World!” in an <code>h1</code> header.</p>
<p>This might seem like a lot of code for something so simple, but let’s go through the code in <code>main()</code> line by line in so you can understand exactly what’s going on.</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1app.html">micro::app</a> app;</div>
</div><!-- fragment --><p>The foundation of building a web-application begins with constructing a <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> object. The <code><a class="el" href="classmicro_1_1app.html" title="app powers all micro++ web applications. ">micro::app</a></code> object can be thought of as a wrapper for a more complicated HTTP server. By default, the server <code>port</code> is set to <code>8080</code> but is easily customizable. Let’s try setting the server to our favorite port, “3000.”</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1app.html">micro::app</a> app(<span class="stringliteral">&quot;3000&quot;</span>); </div>
</div><!-- fragment --><p>Recompile <code>blog_app.cpp</code> and run <code>./blog_app.</code> Your app will now be available on localhost:3000.</p>
<p>Let’s look at the next line in main: </p><div class="fragment"><div class="line">app.add_route(<span class="stringliteral">&quot;/&quot;</span>, hello);</div>
</div><!-- fragment --><p>This next line registers the route "/" with the hello callback. This means that whenever a client requests localhost:8080/ (i.e. the homepage), the <code>hello()</code> callback will be executed and the response constructed in the callback will be served to the end user. Let’s take a closer look at the callback function <code>hello()</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> hello(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(<span class="stringliteral">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The definition of <code>hello</code> conforms to a strict callback interface defined by <code>micro::callback</code>. The callback must accept a const reference <code><a class="el" href="classmicro_1_1request.html" title="The request object provides an API that allows developers access to data from a HTTP request...">micro::request</a></code> and must return a <a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a>.</p>
<p>Within <code>hello()</code>, we perform three easy steps to render the message “hello world” to the user.</p>
<ol type="1">
<li>Construct a response object.</li>
<li>Render the string that will be sent back to the user. Note that we placed hello in html brackets. <code>render_string()</code> sets the default mime type to “text/html”. If you wished to sent a JSON “hello world” message, you could alternatively write <code>resp.render_string(“{\“message\”: \“hello world\”}”, “application/json”)</code>.</li>
<li>Finally, return the response.</li>
</ol>
<p>Under the hood, the web-framework is constructing a properly formatted HTTP response. HTTP responses can get complicated and ugly. Wrapping the HTTP response in the <code><a class="el" href="classmicro_1_1response.html" title="A response object is passed into a url route callback and is handled by the user. ...">micro::response</a></code> creates a much cleaner interface.</p>
<p>To finish off this micro example, let’s look at the last line in <code>main()</code>:</p>
<div class="fragment"><div class="line">app.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
</div><!-- fragment --><p>This line starts the HTTP server that powers micro++. A lot of magic happens when this command is executed. The server starts running and registers all routes and their respective callbacks. Building a blog that returns “hello world” is not very satisfying so let's transform this into a something that looks much more like a blog. Safely kill the server with the SIGINT signal (ctrl-C).</p>
<h2>Creating a blog entry abstraction</h2>
<p>micro++ gives you flexibility on how how you can implement your web apps. However, since micro++ web apps are built with C++, we encourage you to work in a clean object-oriented manner so your apps don’t become a large mess.</p>
<p>In the next few sections we will build this blog app with some practices that we use, but as the programmer you are free to expand on and encouraged to improve them in other apps you build with micro++.</p>
<p>First step in making a blog, we must define the object-oriented abstraction of a blog entry.</p>
<p>Here is how we decided to model a blog entry in its simplest form.</p>
<p><b>blog_entry.hpp</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ctime&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>blog_entry {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string title;</div>
<div class="line">    std::string contents;</div>
<div class="line">    std::string author;</div>
<div class="line">    std::time_t time_posted;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    blog_entry(std::string title, std::string contents, std::string author);</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><p><b>blog_entry.cpp</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;blog_entry.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;regex&gt;</span></div>
<div class="line"></div>
<div class="line">blog_entry::blog_entry(std::string title, std::string contents, std::string author)</div>
<div class="line">{</div>
<div class="line">    this-&gt;title = title;</div>
<div class="line">    this-&gt;contents = contents;</div>
<div class="line">    this-&gt;author = author;</div>
<div class="line">    this-&gt;time_posted = std::time(<span class="keyword">nullptr</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our blog entry has a title, contents, author, and time posted. In our class file we define the constructor which sets all the instance variables. Notice that we included the header <code>&lt;iomanip&gt;</code> and <code>&lt;regex&gt;</code> which will be used later in the tutorial. We are going to keep this example simple, but once finished with the tutorial you are encouraged to add more features such as followers, votes, likes, and comments.</p>
<h2>Building the homepage</h2>
<p>Now that we have modeled a simple blog entry, lets design our homepage. The homepage will have a title with a button that allows you to add a new entry. Let’s add a new route with a callback called <code>homepage()</code> which will be seen by the user when he or she first accesses the blog. Let’s also remove the <code>hello()</code> callback</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;micro/app.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;micro/response.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;micro/request.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> homepage(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    std::ostringstream page;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(page.str());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <a class="code" href="classmicro_1_1app.html">micro::app</a> app;</div>
<div class="line"></div>
<div class="line">    app.add_route(<span class="stringliteral">&quot;/&quot;</span>, homepage);</div>
<div class="line"></div>
<div class="line">    app.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This snippet of code should look very similar to what we saw with the hello world example. There are a couple of changes we would like to discuss. Starting from the top, you will see the additional header <code>#include &lt;sstream&gt;</code>. This allows us to use <code>std::ostringstream</code> which is a buffer that lets us build a string with stream operators. As we did before, we render a string which will be displayed in the browser of the user. Finally, the <code>main</code> method looks exactly like the hello world example except the callback is named <code>homepage</code>.</p>
<p>Now, if we compile our blog and access <code>localhost:8080</code> we will see the welcome page of our application. Next, lets add a button to redirect our user to a new page so that he or she can write a blog entry.</p>
<h2>Adding a button to make a post</h2>
<p>In the homepage callback, let’s add the a button to post a new entry:</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> homepage(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    std::ostringstream page;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;a href=\&quot;/new\&quot;&gt;New Entry&lt;/a&gt;&lt;br/&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(page.str());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above you can see the addition of the line <code>page &lt;&lt; "\&lt;a href=\\"/new\"\&gt;New Entry\&lt;/a\&gt;\&lt;br/\&gt;";</code>. WIthin the string we have a line of html code which is one way to add a redirection button. In this case, clicking “New Entry” will redirect to a new route <code>localhost:8080/new</code>, but upon clicking, you will see a 404 not found error because the route does not exist. Lets define this new route!</p>
<h2>Defining a route to add a new post</h2>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> new_entry(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Don’t forget to register the new route with the app.</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <a class="code" href="classmicro_1_1app.html">micro::app</a> app;</div>
<div class="line">    app.add_route(<span class="stringliteral">&quot;/&quot;</span>, homepage);</div>
<div class="line">    app.add_route(<span class="stringliteral">&quot;/new&quot;</span>, new_entry);</div>
<div class="line"></div>
<div class="line">    app.<a class="code" href="classmicro_1_1app.html#a1fcc51d0124373d86d98d0a6a6cc343a">run</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our callback for <code>new_entry</code> is not very exciting. We create a response, do nothing to it, and return the response. If we click the New Entry button, the server will respond with a 204 no content header. Some browsers are intelligent and will not redirect to a page that responds with a 204, so don’t be worried if nothing happens when you click the “New Entry” link. Lets make our our new page return an html form that gives users the ability to enter a new blog entry.</p>
<h3>Build and render a form for new blog entries</h3>
<p><b>new_entry.html</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;html&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &lt;body&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        &lt;a href=&quot;/&quot;&gt;Homepage&lt;/a&gt;&lt;br/&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        &lt;form action=&quot;new&quot; method=&quot;POST&quot;&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            Name:&lt;br/&gt;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            &lt;br/&gt;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;            Title:&lt;br/&gt;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;            &lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;            &lt;br/&gt;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;            &lt;textarea name=&quot;body&quot; rows=&quot;10&quot; cols=&quot;30&quot;&gt;&lt;/textarea&gt;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;            &lt;br/&gt;&lt;br/&gt;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        &lt;/form&gt;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    &lt;/body&gt;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;&lt;/html&gt;</div>
</div><!-- fragment --><p>Above you will see a simple html form that allows users to make entries into the blog. You can see that we have defined certain input types such as name, title, and body, which correspond to the model attributes in our <code>blog_entry</code> object we defined earlier. Note the line <code>&lt;form action="new" method="POST"&gt;</code>. This key line defines what happens when you press the submit button. When you click submit, it will send a <code>POST</code> request to the route <code>/new</code>. We will discuss the implications of this later, but first let’s make this form visible to users who access the route <code>localhost:8080/new</code> by adding a new method in our callback, <code>response::render_file</code>.</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> new_entry(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line"></div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a10b7f1935d03b5cb63cb508a3e2d267b">render_file</a>(“new_entry.html”);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, when you compile the app and access <code>localhost::8080/new</code> you will see the rendered html file we just wrote. When you fill out the form and press submit, you will notice that the form cleared. As we discussed earlier, what actually happens is that the form is submitting a post request to the route <code>localhost:8080/new</code> with the parameters <code>name</code>, <code>title</code>, and <code>body</code>. Lets discuss how to handle this post request and transform the values into useful input.</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line">std::vector&lt;blog_entry&gt; entries;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> new_entry(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a>&amp; req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(req.<a class="code" href="classmicro_1_1request.html#a8f6a224448ab51600cdf692ebc5d8b84">get_method</a>() == <span class="stringliteral">&quot;POST&quot;</span>) {</div>
<div class="line">        blog_entry new_entry{req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;title&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;body&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;name&quot;</span>)};</div>
<div class="line">        entries.push_back(new_entry);</div>
<div class="line">        resp.<a class="code" href="classmicro_1_1response.html#ad33c5cf35cef13c19b15edbb70c1f0d8">redirect</a>(<span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        resp.<a class="code" href="classmicro_1_1response.html#a10b7f1935d03b5cb63cb508a3e2d267b">render_file</a>(<span class="stringliteral">&quot;new_entry.html&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Lets step through the new new code line by line:</p>
<div class="fragment"><div class="line">std::vector&lt;blog_entry&gt; entries;</div>
</div><!-- fragment --><p>In the first line we added a vector to the global namespace which will store all blog entries.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(req.<a class="code" href="classmicro_1_1request.html#a8f6a224448ab51600cdf692ebc5d8b84">get_method</a>() == <span class="stringliteral">&quot;POST&quot;</span>) {</div>
<div class="line">    blog_entry new_entry{req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;title&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;body&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;name&quot;</span>)};</div>
<div class="line">    entries.push_back(new_entry);</div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#ad33c5cf35cef13c19b15edbb70c1f0d8">redirect</a>(<span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the <code>new_entry()</code> callback, we can see an <code>if</code> statement that checks the type method of the HTTP request. The request object has a method <code>micro::response::get_method</code> that allows you to check the method of the HTTP request. Common HTTP methods include POST, GET, PUT, and DELETE.</p>
<p>We can see if the callback detects a POST, then it populates a new <code>blog_entry</code> object by extracting the post parameters. We can fetch the post parameters with the keys defined in the html form. We then push the new entry into the global vector <code>entries</code> we defined earlier. After inserting the new blog entry, we use the method <code>response::redirect</code> to redirect to back to the homepage.</p>
<div class="fragment"><div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a10b7f1935d03b5cb63cb508a3e2d267b">render_file</a>(<span class="stringliteral">&quot;new_entry.html&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the request given is not a POST request, we render the new entry html as we did earlier.</p>
<h2>Displaying the blog entries</h2>
<p>Now that you have the capability of adding new blog entries to your vector, you will want to be able to display the entries on the homepage. First, you must define the <code>&lt;&lt;</code> operator so that you can load the HTML of a blog entry into the string buffer.</p>
<p>Add the following line to <code>blog_entry.hpp</code></p>
<p><b>blog_entry.hpp</b></p>
<div class="fragment"><div class="line"><span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> blog_entry&amp; be);</div>
</div><!-- fragment --><p>And the following function to <code>blog_entry.cpp</code></p>
<p><b>blog_entry.cpp</b></p>
<div class="fragment"><div class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> blog_entry&amp; be)</div>
<div class="line">{</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;h2&gt;&quot;</span> &lt;&lt; be.title &lt;&lt; <span class="stringliteral">&quot;&lt;/h2&gt;&quot;</span>;</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;em&gt;Posted by &quot;</span> &lt;&lt; be.author;</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot; on &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%a %b %d&quot;</span>);</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%r&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> displayed_contents = std::regex_replace(be.contents, std::regex(<span class="stringliteral">&quot;\\n&quot;</span>), <span class="stringliteral">&quot;&lt;br/&gt;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;/em&gt;&lt;/br&gt;&quot;</span> &lt;&lt; displayed_contents &lt;&lt; <span class="stringliteral">&quot;&lt;/br&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above, we have defined the <code>&lt;&lt;</code> operator for the blog entry in the header file and implemented the method in the class. Lets go through each line of code.</p>
<div class="fragment"><div class="line">os &lt;&lt; <span class="stringliteral">&quot;&lt;h2&gt;&quot;</span> &lt;&lt; be.title &lt;&lt; <span class="stringliteral">&quot;&lt;/h2&gt;&quot;</span>;</div>
<div class="line">os &lt;&lt; <span class="stringliteral">&quot;&lt;em&gt;Posted by &quot;</span> &lt;&lt; be.author;</div>
<div class="line">os &lt;&lt; <span class="stringliteral">&quot; on &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%a %b %d&quot;</span>);</div>
<div class="line">os &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%r&quot;</span>);</div>
</div><!-- fragment --><p>In these lines we print the title, author, date, and time. We use the combination of the methods <code>std::put_time</code> and <code>std::local_time</code> in order to print the time into a nicely formatted string.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> displayed_contents = std::regex_replace(be.contents, std::regex(<span class="stringliteral">&quot;\\n&quot;</span>), <span class="stringliteral">&quot;&lt;br/&gt;&quot;</span>);</div>
<div class="line">os &lt;&lt; <span class="stringliteral">&quot;&lt;/em&gt;&lt;/br&gt;&quot;</span> &lt;&lt; displayed_contents &lt;&lt; <span class="stringliteral">&quot;&lt;/br&gt;&quot;</span>;</div>
</div><!-- fragment --><p>Next we call <code>std::regex_replace</code> on the contents of the blog entry in order to convert all newlines as <code>&lt;br/&gt;</code> statements. This is necessary because HTML does not know how to interpret <code>\n</code> statements. We then append the contents of the blog entry to the stream.</p>
<p>This HTML rendering of a blog entry is not perfect. If an end-user includes tags like <code>&lt;b&gt;</code> and <code>&lt;i&gt;</code> in their name, title, or message body, it can mess up the formatting of the rest of the blog. To fix this, we must sanitize the input!</p>
<p>Add the following function to <code>blog_entry.cpp</code>:</p>
<p><b>blog_entry.cpp</b> </p><div class="fragment"><div class="line">std::string sanitize_input(std::string input)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Sanitize the entry for exploits</span></div>
<div class="line">    <span class="keyword">auto</span> output = std::regex_replace(input, std::regex(<span class="stringliteral">&quot;&amp;&quot;</span>), <span class="stringliteral">&quot;&amp;amp;&quot;</span>);</div>
<div class="line">    output = std::regex_replace(output, std::regex(<span class="stringliteral">&quot;&lt;&quot;</span>), <span class="stringliteral">&quot;&amp;lt;&quot;</span>);</div>
<div class="line">    output = std::regex_replace(output, std::regex(<span class="stringliteral">&quot;&gt;&quot;</span>), <span class="stringliteral">&quot;&amp;gt;&quot;</span>);</div>
<div class="line">    output = std::regex_replace(output, std::regex(<span class="stringliteral">&quot;\\n&quot;</span>), <span class="stringliteral">&quot;&lt;br/&gt;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> output;</div>
<div class="line">}</div>
</div><!-- fragment --><p>And make the following changes to the &lt;&lt; operator:</p>
<div class="fragment"><div class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> blog_entry&amp; be)</div>
<div class="line">{</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;li&gt;&lt;h2&gt;&quot;</span> &lt;&lt; sanitize_input(be.title) &lt;&lt; <span class="stringliteral">&quot;&lt;/h2&gt;&quot;</span>;</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;em&gt;Posted by &quot;</span> &lt;&lt; sanitize_input(be.author);</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot; on &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%a %b %d&quot;</span>);</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; std::put_time(std::localtime(&amp;(be.time_posted)), <span class="stringliteral">&quot;%r&quot;</span>);</div>
<div class="line"></div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;&lt;/em&gt;&lt;br/&gt;&quot;</span> &lt;&lt; sanitize_input(be.contents) &lt;&lt; <span class="stringliteral">&quot;&lt;/br&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we have defined how to print the blog contents, all we need to do is print the contents onto our homepage!</p>
<h2>Printing the blog contents on the homepage</h2>
<p>In order to view the blog posts on the homepage, we need to print them to the screen by updating the <code>homepage</code> callback.</p>
<p><b>blog_app.cpp</b></p>
<div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> homepage(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    std::ostringstream page;</div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome to the blog!!&lt;/h1&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;a href=\&quot;/new\&quot;&gt;New Entry&lt;/a&gt;&lt;br/&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> entry = entries.rbegin(); entry != entries.rend(); ++entry)</div>
<div class="line">        page &lt;&lt; *entry;</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(page.str());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above, you can see the addition of a <code>for</code> loop that will print each <code>blog_entry</code> in the vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> entry = entries.rbegin(); entry != entries.rend(); ++entry)</div>
<div class="line">     page &lt;&lt; *entry;</div>
</div><!-- fragment --><p>This line will loop through the entries which have been added to the blog and use the new <code>&lt;&lt;</code> operator to print them to the screen.</p>
<p>Compile your blog and give it a run. By now you should have minimal running blog! Let’s recap what we have done so far. We defined <code>blog_entry</code> object, how that blog entry should be printed into html, as well as a few callbacks that allow you to post entries and view posted entries.</p>
<h2>Using stylesheets, images, and fragmented templates to style the blog</h2>
<p>As you can probably tell, this simple blog is not pretty or user friendly at all. We’re going to fix that by adding CSS stylesheets and consolidating the blog into a single styled and formatted page. micro++ doesn’t come packaged with a templating system, so we’ll instead accomplish this with what we’ll call fragmented templates.</p>
<p>This means we’ll put fragments of HTML files in a subdirectory called fragments/. Create the following three HTML files now:</p>
<p><b>fragments/header.html</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;!doctype html&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;&lt;title&gt;bjarneblog&lt;/title&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/style.css&quot;&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;body&gt;&lt;div class=&quot;page&quot;&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;h1&gt;Welcome to the bjarneblog!!&lt;/h1&gt;</div>
</div><!-- fragment --><p><b>fragments/footer.html</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;/div&gt;&lt;/body&gt;</div>
</div><!-- fragment --><p><b>fragments/new_entry_form.html</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;form action=&quot;new&quot; method=&quot;POST&quot; class=&quot;add-entry&quot;&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;&lt;dl&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&lt;dt&gt;Name:</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;dd&gt;&lt;input type=&quot;text&quot; size=&quot;30&quot; name=&quot;name&quot;&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;dt&gt;Title:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;dd&gt;&lt;input type=&quot;text&quot; size=&quot;30&quot; name=&quot;title&quot;&gt;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;dt&gt;Text:</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;dd&gt;&lt;textarea name=&quot;body&quot; rows=&quot;5&quot; cols=&quot;40&quot;&gt;&lt;/textarea&gt;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;dd&gt;&lt;input type=&quot;submit&quot; value=&quot;Share&quot;&gt;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/dl&gt;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;&lt;/form&gt;</div>
</div><!-- fragment --><p>Let’s also create a style.css file in a new static/ subdirectory</p>
<p><b>static/style.css</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Adapted from the stylesheet for the flask microblog example (flaskr)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;body            { font-family: sans-serif; background: #C4D8E2; }</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;a, h1, h2       { color: #377BA8; }</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;h1, h2          { font-family: &#39;Verdana&#39;, sans-serif; margin: 0; }</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;h1              { border-bottom: 2px solid #eee; }</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;h2              { font-size: 1.2em; }</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;.page           { margin: 2em auto; width: 35em; border: 5px solid #ccc;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                  padding: 0.8em; background: white; }</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;.entries        { list-style: none; margin: 0; padding: 0; }</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;.entries li     { margin: 0.8em 1.2em; }</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;.entries li h2  { margin-left: -1em; }</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;.add-entry      { font-size: 0.9em; border-bottom: 1px solid #ccc; }</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;.add-entry dl   { font-family: sans-serif; font-weight: bold; }</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;.metanav        { text-align: right; font-size: 0.8em; padding: 0.3em;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                  margin-bottom: 1em; background: #fafafa; }</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;.flash          { background: #CEE5F5; padding: 0.5em;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                  border: 1px solid #AACBE2; }</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;.error          { background: #F0D6D6; padding: 0.5em; }</div>
</div><!-- fragment --><p>When you start a micro++ app, the ./static directory serves as a root for static files by default, so localhost:8080/style.css would serve the above file. This is why we link to /style.css in the <code>static/header.html</code> file.</p>
<p>Now we essentially have the building blocks to create any page on the site.</p>
<p>In blog_app.cpp, add the following function to the top of the file after the #includes:</p>
<p><b>blog_app.cpp</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> render_fragment(std::ostringstream&amp; page, std::string fragment_path)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">char</span> c;</div>
<div class="line">    <span class="keyword">static</span> std::ifstream ifs;</div>
<div class="line">    ifs.open(fragment_path);</div>
<div class="line">    <span class="keywordflow">while</span>(ifs.get(c))</div>
<div class="line">        page &lt;&lt; c;</div>
<div class="line">    ifs.close();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function takes in an <code>ostringstream&amp;</code>, and appends the contents of a file to it. This will let us easily append our HTML fragments to a page that we’re building.</p>
<p>Let’s rewrite our <code>homepage</code> and <code>new_entry</code> callbacks to look like this:</p>
<p><b>blog_app.cpp</b> </p><div class="fragment"><div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> homepage(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    std::ostringstream page;</div>
<div class="line"></div>
<div class="line">    render_fragment(page, <span class="stringliteral">&quot;fragments/header.html&quot;</span>);</div>
<div class="line">    render_fragment(page, <span class="stringliteral">&quot;fragments/new_entry_form.html&quot;</span>);</div>
<div class="line"></div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;ul class=\&quot;entries\&quot;&gt;&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> entry = entries.rbegin(); entry != entries.rend(); ++entry)</div>
<div class="line">        page &lt;&lt; *entry;</div>
<div class="line">    page &lt;&lt; <span class="stringliteral">&quot;&lt;/ul&gt;&quot;</span>;</div>
<div class="line"></div>
<div class="line">    render_fragment(page, <span class="stringliteral">&quot;fragments/footer.html&quot;</span>);</div>
<div class="line"></div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#a2df7cb34f7700a040e1cf7d41360abf4">render_string</a>(page.str());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classmicro_1_1response.html">micro::response</a> new_entry(<span class="keyword">const</span> <a class="code" href="classmicro_1_1request.html">micro::request</a> &amp;req) {</div>
<div class="line">    <a class="code" href="classmicro_1_1response.html">micro::response</a> resp;</div>
<div class="line">    blog_entry new_entry{req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;title&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;body&quot;</span>), req.<a class="code" href="classmicro_1_1request.html#a766d90161e6b77c87a22f53f52541daa">get_post_param</a>(<span class="stringliteral">&quot;name&quot;</span>)};</div>
<div class="line">    entries.push_back(new_entry);</div>
<div class="line">    resp.<a class="code" href="classmicro_1_1response.html#ad33c5cf35cef13c19b15edbb70c1f0d8">redirect</a>(<span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> resp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Above, we have added <code>render_fragment</code> function calls in <code>homepage</code> which can help us keep our callbacks much cleaner. You can notice that we also have moved our <code>new_entry_form.html</code> into the <code>hompage</code> callback. This eliminates unnecessary redirection.</p>
<p>Additionally, we wrapped our blog entries in a an HTML unordered list with appropriate CSS classes. This will make our blog entries appear much more aesthetically pleasing.</p>
<p>For the <code>new_entry</code> callback we have eliminated the new entry form, but we continue to use the <code>new_entry</code> callback to handle POST request for the route. Since it is only hanleing POST requests, we can remove the unnecessary if statement.</p>
<p>Finally, change the <code>new</code> route in <code>main</code> so it only accepts post requests:</p>
<div class="fragment"><div class="line">app.add_route(<span class="stringliteral">&quot;/new&quot;</span>, new_entry, {<span class="stringliteral">&quot;POST&quot;</span>});</div>
</div><!-- fragment --><p>This seems like a lot, but we have actually made the blog a lot simpler and cleaner. First let’s look at the new <code>homepage</code> callback. We build a response by rendering the fragments for a header, for the new entry form, the blog entries, and for the footer.</p>
<p>The <code>new_entry</code> callback will now extract the post requests for a new entry and redirect to the homepage. We can safely do this because we defined that the callback will only be reached when the request method is a POST.</p>
<p>If you build and run the blog, you will see that it looks much nicer with all of the user functionality takes place on the homepage.</p>
<h2>Concluding Remarks</h2>
<p>Congratulations on finishing the tutorial! To learn some more advanced features of micro++ and further improve your blog, try Tutorial 2!</p>
<p>You can view all the source code for the completed tutorial in <code>example_webapps/tutorial/</code> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 30 2015 22:30:20 for Micro++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
